---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)

set.seed(1234)
```

# rollout

<!-- badges: start -->
[![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://lifecycle.r-lib.org/articles/stages.html#experimental)
[![CRAN status](https://www.r-pkg.org/badges/version/rollout)](https://CRAN.R-project.org/package=rollout)
[![R-CMD-check](https://github.com/iancero/rollout/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/iancero/rollout/actions/workflows/R-CMD-check.yaml)
[![Codecov test coverage](https://codecov.io/gh/iancero/rollout/graph/badge.svg)](https://app.codecov.io/gh/iancero/rollout)
<!-- badges: end -->


# Basic Example

We begin with a basic example of the most widely known rollout trial format: a stepped wedge trial. In such a trial, sites are randomly assigned to cohorts. Then, these cohorts are assigned to receive the intervention beginning at different times. Data are recorded for the duration of the study, both before (baseline condition) and after the initiation of an intervention condition. 

In `rollout`, simulating such a trial begins with a matrix specification of the cohorts and their transition points, like so.

```{r}
library(tidyverse)

rollout_schedule <- tribble(
  ~cohort, ~site, ~t1,    ~t2,    ~t3,    ~t4,    ~t5,
  "c1",    "001", "bsln", "intv", "intv", "intv", "intv",
  "c1",    "002", "bsln", "intv", "intv", "intv", "intv",
  "c2",    "003", "bsln", "bsln", "intv", "intv", "intv",
  "c2",    "004", "bsln", "bsln", "intv", "intv", "intv",
  "c3",    "005", "bsln", "bsln", "bsln", "intv", "intv",
  "c3",    "006", "bsln", "bsln", "bsln", "intv", "intv",
  "c4",    "007", "bsln", "bsln", "bsln", "bsln", "intv",
  "c4",    "008", "bsln", "bsln", "bsln", "bsln", "intv"
)
```

This allows the user maximum control over what can become a complex process of scheduling, responding to real world pragmatic constraints. But in this format, it is not yet convenient for simulation, so `rollout` offers the utility function `pivot_schedule_longer()`.

```{r}
rollout_design <- rollout_schedule |> 
  pivot_schedule_longer(t1:t5)

head(rollout_design)
```

In addition to performing a wide-to-long pivot on our schedule, this function has also computed two time columns: chron_time and local_time (0-indexed, to make cohort-specific effects easier to program). It has also constructed a condition column of all the conditions.

Now that the data are in this format, the user is prepared to incoporate any site-level background information they might have. For example, as part of pre-trial assessment and coordination with the study sites, a user might have access to site-level information, like the self-reported readiness to receive the intervention at the site, as well as the relative population of observational units at the site (e.g., classes per timepoint, servicemembers per class). For simplicity, we imagine some of these data below.

```{r}
site_info <- tribble(
  ~site, ~readiness, ~classes_per_time, ~members_per_class,
  "001",    6,          11,                23,
  "002",    7,          15,                25,
  "003",    6,          11,                22,
  "004",    9,          12,                16,
  "005",    7,          11,                24,
  "006",    2,          9,                 22,
  "007",    2,          9,                 16,
  "008",    7,          14,                25,
)
```

And then link them to our design dataframe. We can do this with a simple left_join(), but we are stuck with the fact that two of our columns are actually counts of observational units (in fact, nested units), which will need to be expanded too. Anticipating this is a common situation, `rollout` has its own helper function for joining and expanding such site-related information:


```{r}
rollout_design <- rollout_design |> 
  join_unit_info(
    site_info,
    by = "site",
    uncount_vars = c("classes_per_time", "members_per_class"),
    .ids = c("class", "member")
  )
```
With our design fully expanded, we now need to initialize several replicates of this same dataset for later simulation of data.

```{r}
simulated_trials <- rollout_design |> 
  initialize_replicates(n = 100)

head(simulated_trials)
```


















