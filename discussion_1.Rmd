---
title: "R Notebook"
---

# TODO:

- Have code that can generate data for this case:
  - Conditions that are rolled out
      - true / clean stepped wedge (baseline vs conversion to intervention)
      - everyone is measured at all times
      - use a condition matrix as input
  - 4 levels (cohort - where condition is assigned, clinic, patient, time)
      - specify numbers in nesting structure
      - only things that change across time are patients (whatever their outcome variable is)
          - look at "reach" as the outcome variable for patients: what's the proportion of people screened positive, who eventually get treatment. Among positive screens, who actually gets into treatment
          - generate a changing number of patients each time (poisson variable)
  - With unbalanced / uneven group sizes (that the user can specify)
  - Model should 


- Have a model together that generates random intercepts
- Generate a flow diagram or some pseudocode



- Assigment matrix
  Columns are timepoints
  Rows are the units who will be assigned (e)

- Specify the levels of the hierarchy
- which level of it is used for assignment (hospitals, doctors, etc)
- How many of the next lowest level are within each of the assigned level
- The level below that (e.g., patients) will generally not be the same at each timepoint (this is the denominator for something like reach)
    - So these get newly generated at each timepoint
    - So we'll need to specify the distribution with which they are generated
- For each condition over time, what does the numerator / improvement in the outcome look like? These are fixed effects (then we can add the distribution of errors here too)
- Somehow we need to include ICCs (patients within doctors, doctors within hospitals) - consider taking logs of the proportions to do things on a log scale

- Specifying what the fixed effects are and what their parameters are and how they work on the level of where the assignment occurs (everything else above and below should be random)

- Specify information about number of replications for the generated data. Is the model for analysis the same as the generating model?

- Using a standard binomial proportion variance (pq/n), we want that to be able to vary across situations. For example, MPLUS there is a random slope where the mean is 0, but the regression variance is some fixed quantity.
 
```{r}
library(tidyverse)

data.frame(cohort = rep(1:4, each = 2)) |> 
  mutate(
    hospital = row_number(),
    num_pcps = rpois(n(), lambda = 20)
    )


stepped_wedge_ex
```


# Conclusions

At least for now, assume that we will receive a matrix for the schedule from the user (we don't need to make it for them)

# TODO: how to generate the random effect data (and account for the fact that they can be different across units)

# Discussion - 2024-05-17

## Progress report

Limitations of the lme4 formula syntax:

```{r}
my_model <- y ~ 1 + 3*x1(level = 1) + 4*x2(level = 2) + (1 + x1 + x2 | group)
```

- **Fixed effect coefficients**: The lme4 formula does not allow specifying the actual values of the fixed effect coefficients, which are necessary for data simulation.

 - **Random effect variances**: The lme4 formula does not provide a way to specify the variances of the random effects, which are required for generating simulated data.
 
 - **Residual variance**: The lme4 formula does not explicitly specify the residual variance, which represents the unexplained variability in the response variable.
 
 - **Variable distributions**: The lme4 formula does not specify the exact distributions and parameters of the fixed effect variables, random effects, and residuals.
 
 - **Hierarchical structure**: While the lme4 formula specifies the nesting structure, it does not explicitly indicate the level at which each fixed effect variable occurs in the hierarchy.
 
 - **Correlation structures**: The lme4 formula allows for specifying correlated random effects using the syntax `(1 + variable1 + variable2 | group)`, but it does not provide a way to specify the actual correlation values between the random effects.
 
 - **Data balance**: The lme4 formula assumes a balanced design, meaning that each grouping factor has the same number of observations within each level. It does not inherently handle unbalanced or missing data scenarios.
 
 - **Sample sizes**: The lme4 formula does not specify the sample sizes at each level of the hierarchy, which are necessary for generating simulated data with the desired structure and balance.
 
 - **Additional variables**: The lme4 formula focuses on the variables directly involved in the mixed-effects model and does not account for additional variables that may be relevant for data simulation, such as covariates or variables for data exploration.
 
 
# Alternate syntax

```{r}
library(tidyverse)
library(oursimulationpackage)

simulation_spec <- specify_level(
    level_name = "school",
    level_size = 10,
    level_attrs = list(budget = runif(10, min = 1000, max = 2000))
  ) |>
  specify_level(
    level_name = "student",
    level_size = 20,
    level_attrs = list(age = rnorm(200, mean = 13, sd = 2))
  ) |>
  specify_relationship(
    parent_level = "school",
    child_level = "student",
    relationship_type = "nested"
  )

simulation_data <- generate(simulation_spec)
```


```{r}
specify_fixed(
    var_name = "treatment",
    var_type = "categorical",
    var_levels = c("control", "treatment1", "treatment2"),
    var_probs = c(0.33, 0.33, 0.34)
  ) |>
  specify_fixed(
    var_name = "age",
    var_type = "continuous",
    var_dist = "normal",
    var_params = list(mean = 30, sd = 5)
  )

simulation_spec <- specify_random(
    var_name = "intercept",
    var_type = "intercept",
    var_dist = "normal",
    var_params = list(mean = 0, sd = 1)
  ) |>
  specify_random(
    var_name = "slope",
    var_type = "slope",
    var_by = "treatment",
    var_dist = "normal",
    var_params = list(mean = 0, sd = 0.5)
  )
```

```{r}
stepped_wedge_ex
```

```{r}
library(tidyverse)

stepped_wedge_ex |> 
  pivot_schedule_longer(t1:t9) |> 
  expand_grid(school_id = letters[1:10], subject_id = 1:20) |> 
  group_by(school_id) |> 
  mutate(school_int = rnorm(1, mean = 2, sd = 1.5)) |> 
  ungroup() |> 
  mutate(
    student_score = rnorm(n = n(), mean = 3),
    obs_score = student_score + school_int + rnorm(n())) 
```


```{r}
sigma <- matrix(c(1, .30, .30, 1), nrow = 2, byrow = TRUE)

df <- mvtnorm::rmvnorm(n = 10000, sigma = sigma) |> 
  as.data.frame() |> 
  set_names()

background_df <- expand_grid(cohort = 1:4, school = 1:10) |> 
  group_by(cohort, school) |> 
  mutate(
    size = rpois(n = 1, lambda = 20)
  )



expand_grid(cohort = 1:4, school = 1:10, student = 1:max(background_df$size)) |> 
  group_by(cohort, school) |> 
  dplyr::filter(student <= size)


df <- expand_grid(school_)

df |> 
  cor()
```















